# start_stream Implementation Plan

**Created**: 2025-12-11
**Status**: Ready for Implementation
**Estimated Total Time**: 12-16 hours
**Prerequisites**: PROJECT_STATE.md, START_STREAM_DESIGN.md

---

## Overview

This document provides a **step-by-step implementation plan** for adding the `start_stream` tool to the MCP Stream Workflow Manager. This is the **critical missing piece** that completes the stream lifecycle.

**What start_stream does**:
- Runs in main directory (ONLY legitimate exception to worktree-only rule)
- Creates ALL stream metadata atomically
- Commits metadata to main
- Creates worktree for development
- Returns path and next steps to agent

---

## Implementation Phases

### Phase 1: Foundation - Template Files (1-2 hours)

Create template files that start_stream will use to generate stream metadata.

#### Task 1.1: Create templates/ directory

```bash
mkdir -p templates/
```

#### Task 1.2: Create HANDOFF.template.md

**File**: `templates/HANDOFF.template.md`

```markdown
# Stream Handoff: {{STREAM_TITLE}}

**Stream ID**: {{STREAM_ID}}
**Category**: {{CATEGORY}}
**Priority**: {{PRIORITY}}
**Created**: {{CREATED_AT}}

---

## Objective

{{HANDOFF_CONTENT}}

---

## Resources

**Working Directory**: `{{WORKTREE_PATH}}`
**Branch**: `{{BRANCH_NAME}}`
**Main Project**: `{{PROJECT_ROOT}}`

## Success Criteria

- [ ] All planned work completed
- [ ] TypeScript compilation passes
- [ ] Build succeeds
- [ ] Lint passes
- [ ] Tests pass (if applicable)

---

**Next Steps**:
1. Navigate to worktree: `cd {{WORKTREE_PATH}}`
2. Review this handoff
3. Begin implementation
4. When ready: call `prepare_merge`

---

ü§ñ Generated by Stream Workflow Manager
```

**Variables to replace**:
- `{{STREAM_TITLE}}` - User-provided title
- `{{STREAM_ID}}` - Generated stream ID
- `{{CATEGORY}}` - backend/frontend/infrastructure/etc.
- `{{PRIORITY}}` - critical/high/medium/low
- `{{CREATED_AT}}` - ISO timestamp
- `{{HANDOFF_CONTENT}}` - User-provided handoff text
- `{{WORKTREE_PATH}}` - Absolute path to worktree
- `{{BRANCH_NAME}}` - Branch name (same as stream ID)
- `{{PROJECT_ROOT}}` - Main project path

#### Task 1.3: Create README.template.md

**File**: `templates/README.template.md`

```markdown
# {{STREAM_TITLE}}

**Stream**: {{STREAM_ID}}
**Status**: {{STATUS}}
**Category**: {{CATEGORY}}
**Priority**: {{PRIORITY}}

---

## Description

{{DESCRIPTION}}

## Timeline

- **Created**: {{CREATED_AT}}
- **Updated**: {{UPDATED_AT}}
- **Completed**: {{COMPLETED_AT}}

## Location

- **Worktree**: `{{WORKTREE_PATH}}`
- **Branch**: `{{BRANCH_NAME}}`

## Phases

{{#PHASES}}
- [ ] {{PHASE_NAME}}
{{/PHASES}}

## Documentation

- [Handoff](./HANDOFF.md) - What to work on
- [Status](./STATUS.md) - Current progress

---

ü§ñ Generated by Stream Workflow Manager
```

#### Task 1.4: Create STATUS.template.md

**File**: `templates/STATUS.template.md`

```markdown
# Stream Status: {{STREAM_ID}}

**Last Updated**: {{UPDATED_AT}}
**Current Phase**: {{CURRENT_PHASE}}
**Progress**: {{PROGRESS}}%

---

## Phase Progress

{{#PHASES}}
### {{PHASE_NAME}}
- **Status**: {{PHASE_STATUS}}
- **Completed**: {{PHASE_COMPLETED_AT}}
{{/PHASES}}

---

## Notes

{{NOTES}}

---

ü§ñ Updated by Stream Workflow Manager
```

#### Task 1.5: Create METADATA.template.json

**File**: `templates/METADATA.template.json`

```json
{
  "streamId": "{{STREAM_ID}}",
  "streamNumber": {{STREAM_NUMBER}},
  "title": "{{STREAM_TITLE}}",
  "category": "{{CATEGORY}}",
  "priority": "{{PRIORITY}}",
  "status": "initializing",
  "createdAt": "{{CREATED_AT}}",
  "updatedAt": "{{UPDATED_AT}}",
  "completedAt": null,
  "branch": "{{BRANCH_NAME}}",
  "worktreePath": "{{WORKTREE_PATH}}",
  "phases": {{PHASES_JSON}},
  "currentPhase": null,
  "progress": 0,
  "tags": {{TAGS_JSON}},
  "blockedReason": null
}
```

**Estimated**: 1 hour

---

### Phase 2: Foundation - State Manager (2-3 hours)

Create state management for stream IDs and registry.

#### Task 2.1: Create src/state-manager.ts

**File**: `src/state-manager.ts`

**Purpose**: Manage STREAM_STATE.json with atomic operations

**Interfaces**:
```typescript
export interface StreamState {
  nextStreamId: number;
  streams: Record<string, StreamMetadata>;
  lastSync: string;
}

export interface StreamMetadata {
  streamId: string;
  streamNumber: number;
  title: string;
  category: StreamCategory;
  priority: StreamPriority;
  status: StreamStatus;
  createdAt: string;
  worktreePath: string;
  branch: string;
}
```

**Functions to implement**:
1. `loadState(): Promise<StreamState>` - Read STREAM_STATE.json
2. `saveState(state: StreamState): Promise<void>` - Write STREAM_STATE.json atomically
3. `withStateLock<T>(fn: () => Promise<T>): Promise<T>` - Execute with lock
4. `getNextStreamId(): Promise<number>` - Assign next ID (monotonic)
5. `registerStream(metadata: StreamMetadata): Promise<void>` - Add to registry
6. `updateStream(streamId: string, updates: Partial<StreamMetadata>): Promise<void>`
7. `getStream(streamId: string): Promise<StreamMetadata | null>`
8. `listStreams(filter?: Partial<StreamMetadata>): Promise<StreamMetadata[]>`

**Locking**:
- Use `config.DASHBOARD_LOCK_DIR` for state file lock
- Atomic directory creation (like complete-merge.ts does)
- Retry logic with timeout

**State File Location**: `config.PROJECT_ROOT / config.STREAM_STATE_PATH`

**Initial State** (if file doesn't exist):
```json
{
  "nextStreamId": 1,
  "streams": {},
  "lastSync": "2025-12-11T00:00:00Z"
}
```

**Error Handling**:
- File not found ‚Üí Create with initial state
- JSON parse error ‚Üí Backup corrupt file, create new
- Lock timeout ‚Üí Clear error with fix instructions

**Estimated**: 2-3 hours

#### Task 2.2: Update src/types.ts

Add state manager types to types.ts:
- StreamState interface (if not already there)
- StreamMetadata interface
- Export from types.ts

**Estimated**: 15 minutes

---

### Phase 3: Foundation - Dashboard Manager (2-3 hours)

Create dashboard management for STATUS_DASHBOARD.md.

#### Task 3.1: Create src/dashboard-manager.ts

**File**: `src/dashboard-manager.ts`

**Purpose**: Manage STREAM_STATUS_DASHBOARD.md with atomic updates

**Functions to implement**:
1. `loadDashboard(): Promise<string>` - Read dashboard markdown
2. `saveDashboard(content: string): Promise<void>` - Write atomically
3. `withDashboardLock<T>(fn: () => Promise<T>): Promise<T>` - Execute with lock
4. `addStream(stream: StreamMetadata): Promise<void>` - Add new entry
5. `updateStream(streamId: string, updates: Partial<StreamMetadata>): Promise<void>`
6. `removeStream(streamId: string): Promise<void>` - Move to archived section
7. `parseDashboard(content: string): DashboardData` - Parse markdown to data
8. `formatDashboard(data: DashboardData): string` - Format data to markdown

**Dashboard Format**:
```markdown
# Stream Status Dashboard

**Last Updated**: 2025-12-11 07:00:00

---

## Active Streams (3)

### Stream 042: Add user authentication
- **Status**: üü° In Progress
- **Category**: Backend
- **Priority**: High
- **Branch**: `stream-042-add-authentication`
- **Created**: 2025-12-10
- **Progress**: 60%
- **Current Phase**: Implementation
- **Worktree**: `../worktrees/stream-042-add-authentication`

### Stream 043: Refactor payment service
- **Status**: üü¢ Ready for Merge
- **Category**: Backend
- **Priority**: Medium
- **Branch**: `stream-043-refactor-payments`
- **Created**: 2025-12-11
- **Progress**: 100%
- **Worktree**: `../worktrees/stream-043-refactor-payments`

---

## Completed Streams (25)

See [.project/history/](./history/) for archived streams.

---

ü§ñ Managed by Stream Workflow Manager
```

**Locking**:
- Use `config.DASHBOARD_LOCK_DIR`
- Same pattern as state-manager.ts

**Status Icons**:
- üî¥ Blocked
- üü° In Progress
- üü¢ Ready for Merge
- ‚úÖ Completed
- ‚è∏Ô∏è Paused

**Estimated**: 2-3 hours

---

### Phase 4: Implementation - start_stream Tool (4-6 hours)

Implement the actual start_stream tool.

#### Task 4.1: Create src/tools/start-stream.ts

**File**: `src/tools/start-stream.ts`

**Phases to implement** (from START_STREAM_DESIGN.md):

##### Phase 1: Validation

```typescript
async function validateEnvironment(): Promise<void> {
  // 1. Verify in main directory
  const cwd = process.cwd();
  if (cwd !== config.PROJECT_ROOT) {
    throw new Error(`Must run from main: ${config.PROJECT_ROOT}`);
  }

  // 2. Verify on main branch
  const git = simpleGit(config.PROJECT_ROOT);
  const branch = await git.revparse(['--abbrev-ref', 'HEAD']);
  if (branch.trim() !== 'main') {
    throw new Error('Must be on main branch');
  }

  // 3. Verify main is clean
  const status = await git.status();
  if (!status.isClean()) {
    throw new Error(`Uncommitted changes in main:\n${status.files.map(f => f.path).join('\n')}`);
  }

  // 4. Verify main is up-to-date
  await git.fetch('origin', 'main');
  const behind = await git.raw(['rev-list', 'HEAD..origin/main', '--count']);
  if (parseInt(behind.trim()) > 0) {
    throw new Error('Main is behind origin/main. Pull first: git pull origin main');
  }
}
```

##### Phase 2: Generate Stream ID

```typescript
async function generateStreamId(title: string): Promise<{ streamId: string; streamNumber: number }> {
  // Use state-manager to get next ID
  const streamNumber = await getNextStreamId();

  // Slugify title
  const slug = title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50);

  const streamId = `stream-${streamNumber.toString().padStart(3, '0')}-${slug}`;

  // Verify worktree doesn't exist
  const worktreePath = join(config.WORKTREE_ROOT, streamId);
  if (existsSync(worktreePath)) {
    throw new Error(`Worktree already exists: ${worktreePath}`);
  }

  return { streamId, streamNumber };
}
```

##### Phase 3: Create Metadata Files

```typescript
async function createMetadataFiles(params: StartStreamArgs, streamInfo: StreamInfo): Promise<string[]> {
  const { streamId, streamNumber } = streamInfo;
  const streamDir = join(config.PROJECT_ROOT, '.project/plan/streams', streamId);

  // Create directory
  mkdirSync(streamDir, { recursive: true });

  const filesCreated: string[] = [];

  // 1. HANDOFF.md
  const handoffPath = join(streamDir, 'HANDOFF.md');
  const handoffContent = renderTemplate('HANDOFF.template.md', {
    STREAM_TITLE: params.title,
    STREAM_ID: streamId,
    CATEGORY: params.category,
    PRIORITY: params.priority,
    CREATED_AT: new Date().toISOString(),
    HANDOFF_CONTENT: params.handoff,
    WORKTREE_PATH: join(config.WORKTREE_ROOT, streamId),
    BRANCH_NAME: streamId,
    PROJECT_ROOT: config.PROJECT_ROOT,
  });
  writeFileSync(handoffPath, handoffContent);
  filesCreated.push(handoffPath);

  // 2. README.md
  const readmePath = join(streamDir, 'README.md');
  const readmeContent = renderTemplate('README.template.md', {
    STREAM_TITLE: params.title,
    STREAM_ID: streamId,
    STATUS: 'initializing',
    CATEGORY: params.category,
    PRIORITY: params.priority,
    DESCRIPTION: params.description || 'No description provided',
    CREATED_AT: new Date().toISOString(),
    UPDATED_AT: new Date().toISOString(),
    COMPLETED_AT: '',
    WORKTREE_PATH: join(config.WORKTREE_ROOT, streamId),
    BRANCH_NAME: streamId,
    PHASES: params.estimatedPhases || [],
  });
  writeFileSync(readmePath, readmeContent);
  filesCreated.push(readmePath);

  // 3. STATUS.md
  const statusPath = join(streamDir, 'STATUS.md');
  const statusContent = renderTemplate('STATUS.template.md', {
    STREAM_ID: streamId,
    UPDATED_AT: new Date().toISOString(),
    CURRENT_PHASE: 'Not started',
    PROGRESS: 0,
    PHASES: params.estimatedPhases || [],
    NOTES: '',
  });
  writeFileSync(statusPath, statusContent);
  filesCreated.push(statusPath);

  // 4. METADATA.json
  const metadataPath = join(streamDir, 'METADATA.json');
  const metadata = {
    streamId,
    streamNumber,
    title: params.title,
    category: params.category,
    priority: params.priority,
    status: 'initializing',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    completedAt: null,
    branch: streamId,
    worktreePath: join(config.WORKTREE_ROOT, streamId),
    phases: params.estimatedPhases || [],
    currentPhase: null,
    progress: 0,
    tags: params.tags || [],
    blockedReason: null,
  };
  writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
  filesCreated.push(metadataPath);

  return filesCreated;
}
```

##### Phase 4: Update Dashboard and State

```typescript
async function updateDashboardAndState(params: StartStreamArgs, streamInfo: StreamInfo): Promise<void> {
  const { streamId, streamNumber } = streamInfo;

  // 1. Update STREAM_STATE.json
  await registerStream({
    streamId,
    streamNumber,
    title: params.title,
    category: params.category,
    priority: params.priority,
    status: 'initializing',
    createdAt: new Date().toISOString(),
    worktreePath: join(config.WORKTREE_ROOT, streamId),
    branch: streamId,
  });

  // 2. Update STATUS_DASHBOARD.md
  await addStream({
    streamId,
    streamNumber,
    title: params.title,
    category: params.category,
    priority: params.priority,
    status: 'initializing',
    createdAt: new Date().toISOString(),
    worktreePath: join(config.WORKTREE_ROOT, streamId),
    branch: streamId,
  });
}
```

##### Phase 5: Git Commit

```typescript
async function commitMetadata(streamId: string, filesCreated: string[]): Promise<string> {
  const git = simpleGit(config.PROJECT_ROOT);

  // Stage all files
  await git.add('.project/plan/streams/' + streamId);
  await git.add('.project/STREAM_STATUS_DASHBOARD.md');
  await git.add('.project/STREAM_STATE.json');

  // Create commit
  const commitMessage = `üöÄ Initialize ${streamId}: ${params.title}

Stream initialization by MCP Stream Workflow Manager

Category: ${params.category}
Priority: ${params.priority}
Branch: ${streamId}
Worktree: ${join(config.WORKTREE_ROOT, streamId)}

This commit creates stream metadata in main before worktree creation.
This is the ONLY operation that legitimately modifies main directly.
All development work will occur in the worktree.

Metadata files:
${filesCreated.map(f => '- ' + f.replace(config.PROJECT_ROOT, '')).join('\n')}
`;

  await git.commit(commitMessage);

  // Push to origin
  await git.push('origin', 'main');

  // Get commit hash
  const log = await git.log({ maxCount: 1 });
  return log.latest?.hash || '';
}
```

##### Phase 6: Create Worktree

```typescript
async function createWorktree(streamId: string): Promise<string> {
  const worktreePath = join(config.WORKTREE_ROOT, streamId);
  const git = simpleGit(config.PROJECT_ROOT);

  // Create worktree with new branch
  await git.raw(['worktree', 'add', worktreePath, '-b', streamId]);

  // Copy HANDOFF.md to worktree root for easy access
  const handoffSource = join(config.PROJECT_ROOT, '.project/plan/streams', streamId, 'HANDOFF.md');
  const handoffDest = join(worktreePath, 'HANDOFF.md');
  copyFileSync(handoffSource, handoffDest);

  return worktreePath;
}
```

##### Phase 7: Main Function

```typescript
export async function startStream(args: StartStreamArgs): Promise<MCPResponse> {
  try {
    // Phase 1: Validation
    await validateEnvironment();

    // Phase 2: Generate stream ID
    const streamInfo = await generateStreamId(args.title);
    const { streamId, streamNumber } = streamInfo;

    // Phase 3: Create metadata files
    const filesCreated = await createMetadataFiles(args, streamInfo);

    // Phase 4: Update dashboard and state
    await updateDashboardAndState(args, streamInfo);

    // Phase 5: Commit metadata
    const commitHash = await commitMetadata(streamId, filesCreated);

    // Phase 6: Create worktree
    const worktreePath = await createWorktree(streamId);

    // Phase 7: Return success
    const response: StartStreamResponse = {
      success: true,
      streamId,
      streamNumber,
      worktreePath,
      branchName: streamId,
      metadata: {
        planDir: `.project/plan/streams/${streamId}`,
        filesCreated: filesCreated.map(f => f.replace(config.PROJECT_ROOT, '')),
        commitHash,
      },
      nextSteps: [
        `Navigate to worktree: cd ${worktreePath}`,
        `Review handoff: cat HANDOFF.md`,
        `Begin development work`,
        `When ready to merge: call prepare_merge`,
      ],
      handoffPath: join(worktreePath, 'HANDOFF.md'),
    };

    return {
      content: [
        {
          type: 'text',
          text: formatSuccessResponse(response),
        },
      ],
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      content: [
        {
          type: 'text',
          text: `start_stream failed: ${errorMessage}`,
        },
      ],
    };
  }
}
```

**Estimated**: 4-6 hours

---

#### Task 4.2: Add template rendering utility

**File**: `src/utils/template-renderer.ts`

Simple mustache-style template rendering:

```typescript
export function renderTemplate(templateName: string, variables: Record<string, any>): string {
  const templatePath = join(__dirname, '../../templates', templateName);
  let content = readFileSync(templatePath, 'utf-8');

  // Replace {{VARIABLE}} with value
  for (const [key, value] of Object.entries(variables)) {
    const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
    content = content.replace(regex, String(value));
  }

  // Handle {{#ARRAY}} ... {{/ARRAY}} for arrays
  content = renderArrayBlocks(content, variables);

  return content;
}

function renderArrayBlocks(content: string, variables: Record<string, any>): string {
  const arrayBlockRegex = /\{\{#(\w+)\}\}([\s\S]*?)\{\{\/\1\}\}/g;

  return content.replace(arrayBlockRegex, (match, arrayName, blockContent) => {
    const array = variables[arrayName];
    if (!Array.isArray(array)) return '';

    return array.map(item => {
      let rendered = blockContent;
      for (const [key, value] of Object.entries(item)) {
        const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        rendered = rendered.replace(regex, String(value));
      }
      return rendered;
    }).join('\n');
  });
}
```

**Estimated**: 1 hour

---

#### Task 4.3: Update src/types.ts

Add interfaces:

```typescript
export interface StartStreamArgs {
  title: string;
  category: StreamCategory;
  priority: StreamPriority;
  handoff: string;
  description?: string;
  estimatedPhases?: string[];
  tags?: string[];
}

export interface StartStreamResponse {
  success: boolean;
  streamId: string;
  streamNumber: number;
  worktreePath: string;
  branchName: string;
  metadata: {
    planDir: string;
    filesCreated: string[];
    commitHash: string;
  };
  nextSteps: string[];
  handoffPath: string;
}
```

**Estimated**: 15 minutes

---

#### Task 4.4: Register tool in src/server.ts

Add to TOOLS array:

```typescript
{
  name: 'start_stream',
  description:
    'Initialize a new development stream. ' +
    'RUNS IN MAIN (only legitimate exception to worktree-only rule). ' +
    'Creates metadata, commits to main, creates worktree. ' +
    'Call this BEFORE beginning work on a new feature/fix.',
  inputSchema: {
    type: 'object',
    properties: {
      title: {
        type: 'string',
        description: 'Human-readable stream title'
      },
      category: {
        type: 'string',
        enum: ['backend', 'frontend', 'infrastructure', 'testing', 'documentation', 'refactoring'],
        description: 'Stream category'
      },
      priority: {
        type: 'string',
        enum: ['critical', 'high', 'medium', 'low'],
        description: 'Stream priority'
      },
      handoff: {
        type: 'string',
        description: 'HANDOFF.md content - what the agent should work on'
      },
      description: {
        type: 'string',
        description: 'Additional context for README.md (optional)'
      },
      estimatedPhases: {
        type: 'array',
        items: { type: 'string' },
        description: 'Optional phase names for tracking'
      },
      tags: {
        type: 'array',
        items: { type: 'string' },
        description: 'Optional tags for categorization'
      }
    },
    required: ['title', 'category', 'priority', 'handoff']
  }
}
```

Add to switch statement:

```typescript
case 'start_stream':
  result = await startStream(args as StartStreamArgs);
  break;
```

**Estimated**: 30 minutes

---

### Phase 5: Testing (3-4 hours)

#### Task 5.1: Create test configuration

**File**: `vitest.config.ts`

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
    },
  },
});
```

**Estimated**: 15 minutes

---

#### Task 5.2: Create test fixtures

**Directory**: `tests/fixtures/`

Create mock git repository for testing:
- Mock STREAM_STATE.json
- Mock STATUS_DASHBOARD.md
- Mock templates

**Estimated**: 1 hour

---

#### Task 5.3: Write unit tests

**File**: `tests/start-stream.test.ts`

Test cases:
1. ‚úÖ Should create stream with all metadata files
2. ‚úÖ Should generate sequential stream IDs
3. ‚úÖ Should sanitize stream title for filesystem
4. ‚úÖ Should error if not in main directory
5. ‚úÖ Should error if uncommitted changes exist
6. ‚úÖ Should error if main is behind origin
7. ‚úÖ Should error if worktree already exists
8. ‚úÖ Should update STREAM_STATE.json correctly
9. ‚úÖ Should update STATUS_DASHBOARD.md correctly
10. ‚úÖ Should commit metadata with correct message
11. ‚úÖ Should create worktree with correct branch
12. ‚úÖ Should copy HANDOFF.md to worktree root
13. ‚úÖ Should return correct response structure

**Estimated**: 2-3 hours

---

### Phase 6: Documentation Updates (1 hour)

#### Task 6.1: Update README.md

Add start_stream to "Available Tools" section.

Add usage example.

**Estimated**: 20 minutes

---

#### Task 6.2: Update DEVELOPMENT.md

Add start_stream to implementation status.

**Estimated**: 10 minutes

---

#### Task 6.3: Update GETTING_STARTED.md

Update "Current Status" to show start_stream implemented.

**Estimated**: 10 minutes

---

#### Task 6.4: Update PROJECT_STATE.md

Mark start_stream as implemented.

Update gap analysis.

**Estimated**: 20 minutes

---

## Complete Checklist

Use this checklist to track implementation progress:

### Phase 1: Templates ‚úÖ
- [ ] Create templates/ directory
- [ ] Create HANDOFF.template.md
- [ ] Create README.template.md
- [ ] Create STATUS.template.md
- [ ] Create METADATA.template.json

### Phase 2: State Manager ‚úÖ
- [ ] Create src/state-manager.ts
- [ ] Implement loadState()
- [ ] Implement saveState()
- [ ] Implement withStateLock()
- [ ] Implement getNextStreamId()
- [ ] Implement registerStream()
- [ ] Implement updateStream()
- [ ] Implement getStream()
- [ ] Implement listStreams()
- [ ] Update src/types.ts

### Phase 3: Dashboard Manager ‚úÖ
- [ ] Create src/dashboard-manager.ts
- [ ] Implement loadDashboard()
- [ ] Implement saveDashboard()
- [ ] Implement withDashboardLock()
- [ ] Implement addStream()
- [ ] Implement updateStream()
- [ ] Implement removeStream()
- [ ] Implement parseDashboard()
- [ ] Implement formatDashboard()

### Phase 4: start_stream Tool ‚úÖ
- [ ] Create src/tools/start-stream.ts
- [ ] Implement Phase 1: Validation
- [ ] Implement Phase 2: Generate stream ID
- [ ] Implement Phase 3: Create metadata files
- [ ] Implement Phase 4: Update dashboard and state
- [ ] Implement Phase 5: Git commit
- [ ] Implement Phase 6: Create worktree
- [ ] Implement Phase 7: Main function
- [ ] Create src/utils/template-renderer.ts
- [ ] Update src/types.ts (StartStreamArgs, StartStreamResponse)
- [ ] Register tool in src/server.ts

### Phase 5: Testing ‚úÖ
- [ ] Create vitest.config.ts
- [ ] Create test fixtures
- [ ] Write start-stream.test.ts (13 test cases)
- [ ] All tests pass
- [ ] Coverage >80%

### Phase 6: Documentation ‚úÖ
- [ ] Update README.md
- [ ] Update DEVELOPMENT.md
- [ ] Update GETTING_STARTED.md
- [ ] Update PROJECT_STATE.md

### Final Verification ‚úÖ
- [ ] Build succeeds: `pnpm build`
- [ ] Tests pass: `pnpm test`
- [ ] Lint passes: `pnpm lint`
- [ ] TypeScript check passes: `pnpm typecheck`
- [ ] Tool registered correctly
- [ ] Can call start_stream from Claude Code
- [ ] Creates all metadata files
- [ ] Commits to main correctly
- [ ] Creates worktree successfully
- [ ] Full lifecycle works (start ‚Üí develop ‚Üí prepare ‚Üí complete ‚Üí archive)

---

## Time Estimates

| Phase | Tasks | Estimated Time |
|-------|-------|----------------|
| Phase 1: Templates | 5 tasks | 1-2 hours |
| Phase 2: State Manager | 10 tasks | 2-3 hours |
| Phase 3: Dashboard Manager | 9 tasks | 2-3 hours |
| Phase 4: start_stream Tool | 4 tasks | 4-6 hours |
| Phase 5: Testing | 3 tasks | 3-4 hours |
| Phase 6: Documentation | 4 tasks | 1 hour |
| **TOTAL** | **35 tasks** | **13-19 hours** |

**Conservative Estimate**: 16-19 hours
**Optimistic Estimate**: 13-15 hours
**Realistic Estimate**: 14-16 hours

---

## Dependencies Between Phases

```
Phase 1 (Templates)
  ‚Üì
Phase 2 (State Manager) ‚Üê‚Üí Phase 3 (Dashboard Manager)
  ‚Üì                              ‚Üì
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Phase 4 (start_stream Tool) ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
                   Phase 5 (Testing)
                          ‚Üì
                   Phase 6 (Documentation)
```

**Can be parallelized**:
- Phase 2 and Phase 3 (state-manager and dashboard-manager are independent)

**Must be sequential**:
- Phase 1 must complete before Phase 4 (templates needed)
- Phases 2 & 3 must complete before Phase 4 (managers needed)
- Phase 4 must complete before Phase 5 (can't test what doesn't exist)

---

## Risk Mitigation

### Risk 1: Template rendering complexity

**Mitigation**: Start with simple {{VARIABLE}} replacement. Add array support only if needed.

### Risk 2: State file corruption

**Mitigation**:
- Always backup before writing
- Validate JSON after parsing
- Provide recovery instructions in errors

### Risk 3: Lock timeouts

**Mitigation**:
- Use same proven locking pattern from complete-merge.ts
- Implement stale lock detection
- Clear error messages

### Risk 4: Git operations fail

**Mitigation**:
- Wrap all git operations in try-catch
- Provide rollback instructions
- Test with edge cases (dirty working tree, network issues)

---

## Success Criteria

The implementation is **complete** when:

1. ‚úÖ All 35 checklist items are done
2. ‚úÖ All tests pass (`pnpm test`)
3. ‚úÖ Build succeeds (`pnpm build`)
4. ‚úÖ TypeScript compiles without errors
5. ‚úÖ start_stream can be called from Claude Code
6. ‚úÖ Full stream lifecycle works end-to-end:
   - Call start_stream ‚Üí creates metadata, worktree
   - Develop in worktree
   - Call prepare_merge ‚Üí merges main, validates
   - Call complete_merge ‚Üí fast-forwards main
   - Call complete_stream ‚Üí archives, cleans up
7. ‚úÖ Documentation is updated
8. ‚úÖ No regressions in existing tools

---

## Post-Implementation

After start_stream is complete:

1. **Test with real streams** - Use for actual development
2. **Gather feedback** - Adjust based on usage
3. **Consider enhancements**:
   - Stream dependencies
   - Templates per category
   - Auto-planning from user request
   - Dashboard web UI

---

**Plan Status**: ‚úÖ Ready for Implementation
**Next Action**: Begin Phase 1 (Create templates)
**Estimated Completion**: 14-16 hours from start

---

**Document Version**: 1.0
**Created**: 2025-12-11
**Created By**: The Collective
